div#search-app
  div.browse-panel
    div.search-field
      input type="text" placeholder="Search..." @input="inputChanged()" v-model="searchQuery" @keydown.esc="clearInputField()" @keydown.enter="clearInputField()" @keydown.down="nextResult()" @keydown.up="previousResult()" @keydown.left.prevent="previousResult()" @keydown.229.prevent="nextResult()"
      div.loading-circles v-if="loading"
        div
        div
        div
    div.search-results
      div v-for="(result, resultIndex) in searchResults" :id="'search-result-' + resultIndex" class="result-item" :class="[selectedWord == result[0] ? 'selected' : null, highlightedWordIndex === resultIndex ? 'highlighted' : null]" @click="openWord(resultIndex)"
        div class="common-icon" :class="result[2] ? 'common' : 'uncommon'" &#x2b50;
        div class="result" = "{{result[1]}}"
        div v-if="result[3]" class="learned-icon"
  div.contents-panel
    vue-word v-if="wordData" :seq="selectedWord" :j="wordData" :editing="true"

javascript:
  var app = new Vue({
    el: '#search-app',
    data: {
      searchQuery: '',
      previousQuery: '',
      searchResults: [],
      selectedWord: null,
      highlightedWordIndex: null,
      wordData: null,
      loading: false
    },
    computed: {
    },
    methods: {
      inputChanged() {
        this.searchQuery = this.searchQuery.replace(/、/g, '')
        this.searchDebounce();
      },
      searchDebounce: debounce(function(){this.search();}, 250),
      search(openWordAtIndex = null) {
        var app = this;
        var query = this.searchQuery;

        // Prevent request while composing japanese text sing IME
        // Otherwise, same (unchanged) request will be sent after each key press
        if (this.searchQuery === this.previousQuery) return;
        this.loading = true;

        $.ajax({
          url: "#{{path_to(:search2)}}",
          method: 'POST',
          data: {query: query}
        }).done(data => {
          // If input field hasn't been changed while we're trying to get results
          if (query === app.searchQuery) {
            app.highlightedWordIndex = null;
            var j = JSON.parse(data);
            app.searchResults = j;
            app.previousQuery = query;
            app.loading = false;

            history.pushState({}, query, '?query=' + query);
            document.title = query;

            if (j.length > 0) {
              app.openWord(openWordAtIndex || 0);
            }
          }
        });
      },
      openWord(index) {
        var app = this;
        var seq = this.searchResults[index][0];
        this.highlightedWordIndex = index;
        this.selectedWord = seq;
        this.wordData = null;
        this.loading = true;

        $.ajax({
          url: "#{{path_to(:word_details)}}",
          method: 'GET',
          data: {seq: seq}
        }).done(data => {
          if (seq === app.selectedWord) {
            var j = JSON.parse(data);
            app.wordData = j;
            app.loading = false;

            // update current location
            u = new URLSearchParams(location.search);
            u.set('index', index);
            history.replaceState({}, '', '?' + u.toString());
          }
        });
      },
      openWordDebounced: debounce(function(){
        this.openWord(this.highlightedWordIndex);
      }, 250),
      nextResult() {
        if (this.searchResults.length === 0) return;

        if (this.highlightedWordIndex === null) {
          this.highlightedWordIndex = 0;
        } else {
          this.highlightedWordIndex += 1;
        }

        if (this.highlightedWordIndex === this.searchResults.length) {
          this.highlightedWordIndex = 0;
        }

        this.openWordDebounced();
      },
      previousResult() {
        if (this.searchResults.length === 0) return;

        if (this.highlightedWordIndex === null) {
          this.highlightedWordIndex = this.searchResults.length - 1;
        } else {
          this.highlightedWordIndex -= 1;
        }

        if (this.highlightedWordIndex === -1) {
          this.highlightedWordIndex = this.searchResults.length - 1;
        }

        this.openWordDebounced();
      },
      clearInputField() {
        this.searchQuery = '';
        this.previousQuery = '';
      },
    }, // end of methods
    mounted() {
      var u = new URLSearchParams(location.search)
      if (u.has('query')) {
        this.searchQuery = u.get('query');
        this.search(u.has('index') ? u.get('index') : null);
      }
    }
  });

  document.onclick = function(){
    var f = document.activeElement;
    if (f.nodeName === "TEXTAREA" || (f.nodeName === "INPUT" && f.type === "text")) {
      return;
    } else if (window.getSelection().toString() === '') {
      $('#search-app .browse-panel input').focus()
    }
  };

  // Mobile browsers proper height hack; Source: https://css-tricks.com/the-trick-to-viewport-units-on-mobile/
  function correctVH() {
    // First we get the viewport height and we multiple it by 1% to get a value for a vh unit
    let vh = window.innerHeight * 0.01;
    // Then we set the value in the --vh custom property to the root of the document
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  };
  correctVH();
  window.addEventListener('resize', correctVH);

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
        args = arguments;
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      }, wait);
      if (callNow) func.apply(context, args);
    }
  }
