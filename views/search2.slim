div#search-app
  div.browse-panel
    div.search-field
      input type="text" placeholder="Search..." @input="searchDebounce()" v-model="searchQuery" @keydown.esc="clearInputField()" @keydown.down="nextResult()" @keydown.up="previousResult()" @keydown.left.prevent="previousResult()" @keydown.enter="nextResult()"
      div.loading-circles v-if="loading"
        div
        div
        div
    div.search-method
      div :class="searchMethod == 'forward' ? 'selected' : null" @click="setSearchMethod('forward')" FWD
      div :class="searchMethod == 'kanji'   ? 'selected' : null" @click="setSearchMethod('kanji')" KNJ
      div :class="searchMethod == 'english' ? 'selected' : null" @click="setSearchMethod('english')" ENG
    div.search-results
      div v-for="(result, resultIndex) in searchResults" :id="'search-result-' + resultIndex" class="result-item" :class="[selectedWord == result[0] ? 'selected' : null, highlightedWordIndex === resultIndex ? 'highlighted' : null]" @click="openWord(resultIndex)"
        div class="title"
          div class="common-icon" :class="result[4] ? 'common' : 'uncommon'" &#x2b50;
          div class="text" = "{{result[1]}}"
          div v-if="result[5]" class="learned-icon"
        div class="details" = "{{result[2]}}ãƒ»{{result[3]}}"
  div.contents-panel
    vue-word v-if="wordData" :seq="selectedWord" :j="wordData" :editing="true" @search="searchExec"

javascript:
  var app = new Vue({
    el: '#search-app',
    data: {
      searchQuery: '',
      previousQuery: '',
      searchResults: [],
      selectedWord: null,
      highlightedWordIndex: null,
      wordData: null,
      loading: false,
      searchMethod: 'forward',
    },
    computed: {
      searchUrl() {
        if (this.searchMethod == 'forward') {
          return "#{{path_to(:search2)}}";
        } else if (this.searchMethod == 'kanji') {
          return "#{{path_to(:search_kanji)}}";
        } else if (this.searchMethod == 'english') {
          return "#{{path_to(:search_english)}}";
        }
      }
    },
    methods: {
      searchDebounce: debounce(function(){this.search();}, 250),
      searchExec(query, method) {
        this.searchMethod = method;
        this.previousQuery = '';
        this.searchQuery = query;
        this.search(-1);
      },
      search(openWordAtIndex = null, popHistory = true) {
        var app = this;
        var query = this.searchQuery;

        // Prevent request while composing japanese text sing IME
        // Otherwise, same (unchanged) request will be sent after each key press
        if (this.searchQuery === this.previousQuery) return;
        if (this.searchQuery.trim() === '') return;
        this.loading = true;

        $.ajax({
          url: app.searchUrl,
          method: 'POST',
          data: {query: query}
        }).done(data => {
          // If input field hasn't been changed while we're trying to get results
          if (query === app.searchQuery) {
            app.highlightedWordIndex = null;
            var j = JSON.parse(data);
            app.searchResults = j;
            app.previousQuery = query;
            app.loading = false;

            if (popHistory) {
              history.pushState({}, query, '?query=' + query + '&method=' + app.searchMethod);
            }
            document.title = query;

            if (j.length > 0 && openWordAtIndex !== -1) {
              app.openWord(openWordAtIndex || 0);
            }
          }
        });
      },
      setSearchMethod(method) {
        this.searchMethod = method;
        this.previousQuery = '';
        this.search(-1);
      },
      openWord(index) {
        var app = this;
        var seq = this.searchResults[index][0];
        this.highlightedWordIndex = index;
        this.selectedWord = seq;
        this.wordData = null;
        this.loading = true;

        $.ajax({
          url: "#{{path_to(:word_details)}}",
          method: 'GET',
          data: {seq: seq}
        }).done(data => {
          if (seq === app.selectedWord) {
            var j = JSON.parse(data);
            app.wordData = j;
            app.loading = false;

            // update current location
            u = new URLSearchParams(location.search);
            u.set('index', index);
            history.replaceState({}, '', '?' + u.toString());
          }
        });
      },
      openWordDebounced: debounce(function(){
        this.openWord(this.highlightedWordIndex);
      }, 250),
      nextResult() {
        if (this.searchResults.length === 0) return;

        if (this.highlightedWordIndex === null) {
          this.highlightedWordIndex = 0;
        } else {
          this.highlightedWordIndex += 1;
        }

        if (this.highlightedWordIndex === this.searchResults.length) {
          this.highlightedWordIndex = 0;
        }

        this.openWordDebounced();
      },
      previousResult() {
        if (this.searchResults.length === 0) return;

        if (this.highlightedWordIndex === null) {
          this.highlightedWordIndex = this.searchResults.length - 1;
        } else {
          this.highlightedWordIndex -= 1;
        }

        if (this.highlightedWordIndex === -1) {
          this.highlightedWordIndex = this.searchResults.length - 1;
        }

        this.openWordDebounced();
      },
      clearInputField() {
        this.searchQuery = '';
        this.previousQuery = '';
      },
    }, // end of methods
    mounted() {
      var app = this;
      var loadContent = function () {
        var u = new URLSearchParams(location.search);
        console.log('load content ' + u);
        if (u.has('query')) {
          app.searchQuery = u.get('query');
          app.searchMethod = u.get('method') || 'forward';
          app.search(u.has('index') ? Number.parseInt(u.get('index')) : null, false);
        }
        return true;
      }
      loadContent();
      window.onpopstate = loadContent;
    }
  });

  document.onclick = function(){
    var f = document.activeElement;
    if (f.nodeName === "TEXTAREA" || (f.nodeName === "INPUT" && f.type === "text")) {
      return;
    } else if (window.getSelection().toString() === '') {
      $('#search-app .browse-panel input').focus()
    }
  };

  // Mobile browsers proper height hack; Source: https://css-tricks.com/the-trick-to-viewport-units-on-mobile/
  function correctVH() {
    // First we get the viewport height and we multiple it by 1% to get a value for a vh unit
    let vh = window.innerHeight * 0.01;
    // Then we set the value in the --vh custom property to the root of the document
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  };
  correctVH();
  window.addEventListener('resize', correctVH);

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
        args = arguments;
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      }, wait);
      if (callNow) func.apply(context, args);
    }
  }
