ruby:
  word_empty_data = {seq: nil, en: nil, ru: nil, jlptn: nil, nf: nil, krebs: nil, progresses: nil, shortWords: nil, longWords: nil,
         rawSentences: nil, sentences: nil, comment: nil, cards: nil, kanjis: nil, paths: nil,
         forms: {nowLoading: false, comment: false, kreb: nil, card: nil} }
  word_seq = params[:id] || @word_seq

div.word-card#word-card-app

  div v-if="!seq && forms.nowLoading" style="opacity: 0.4"
    div.center-block
      div Loading word data...
      div style="font-size: 0.8em" JavaScript should be enabled.

  div v-else-if="seq !== null"
    div.word-krebs.center-block.expandable-list
      div.expandable-list-item v-for="kreb of krebs"
        div
          div.word-kreb :class="krebClasses[kreb.title]" @click="openKrebForm(kreb.title)" = "{{kreb.title}}"
        div.expandable-list-arrow v-if="kreb.title === forms.kreb"

    div.expandable-list-container v-if="forms.kreb !== null"
      div.center-block
        span v-if="selectedKrebProgress.learned_at"
          = "{{selectedKrebProgress.learned_at ? 'learned ' : ''}}"
          span v-if="selectedKrebProgress.burned_at" burned
          span v-else="true"
            a @click="burnWord(forms.kreb, selectedKrebProgress.id)" burn!
        span v-else="true"
          a v-if="!selectedKrebProgress.flagged" @click="flagWord(forms.kreb)" flag!
          a @click="learnWord(forms.kreb)" learn!
        div v-for="kanji of kanjis" v-if="forms.kreb.indexOf(kanji.title) !== -1"
          div.hr-title: span = '{{kanji.title}}'
          span = '{{kanji.title}}'
          span v-if="kanji.jlptn" = ' · JLPT N{{kanji.jlptn}}'
          span v-if="kanji.wk_level"    = ' · WK #{{kanji.wk_level}}'
          span v-if="kanji.english" = '：{{kanji.english.join("; ")}}'
          div
            span v-if="kanji.on" = '【音読み】{{ kanji.on.join(" · ") }} '
            span v-if="kanji.kun" = '【訓読み】{{ kanji.kun.join(" · ") }} '
            //span v-if="kanji.nanori" = '【名乗り】{{ kanji.nanori.join(" · ") }} '
          div v-if="kanji.wk_level"
            span style="font-weight: bold" Meaning:
            span< v-html="stripBB(kanji.mmne)"
            span< style="font-style: italic" v-html="stripBB(kanji.mhnt)"
          div v-if="kanji.wk_level"
            span style="font-weight: bold" Reading:
            span< v-html="stripBB(kanji.rmne)"
            span< style="font-style: italic" v-html="stripBB(kanji.rhnt)"

    - bullets = %w(① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿) # white circled numbers

    div.word-glosses.center-block
      div.word-gloss-flag &#x1f1ec;&#x1f1e7;
      span v-for="(gloss, glossIndex) of en"
        span v-if="en.length > 1" = "{{bullets[glossIndex]}} "
        span class="word-gloss-pos" v-if="gloss.pos" = '{{gloss.pos.map(i => i.replace(/^.(.*).$/, "$1")).join(", ")}} '
        = "{{gloss.gloss.join(', ')}} "
    div.word-glosses.center-block v-if="ru && ru.length > 0"
      div.word-gloss-flag &#x1f1f7;&#x1f1fa;
      span v-for="(gloss, glossIndex) of ru"
        span v-if="ru.length > 1" = "{{bullets[glossIndex]}} "
        span class="word-gloss-pos" v-if="gloss.pos" = '{{gloss.pos.map(i => i.replace(/^.(.*).$/, "$1")).join(", ")}} '
        = "{{gloss.gloss.join(', ')}} "

    div.word-glosses.center-block v-if="cards.length > 0"
      div.word-gloss-flag &#x1f980;
      div.expandable-list style="display: inline-block"
        div.expandable-list-item v-for="(card, cardIndex) of cards"
          div.word-gloss @click="openCardForm(cardIndex)"
            div.level-wrapper = '{{card.level}}'
            = '{{card.title}} ({{card.en}})'
          div.expandable-list-arrow v-if="cardIndex === forms.card"

    div.expandable-list-container.word-gloss-expanded v-if="forms.card !== null"
      div.center-block
        span = '{{selectedCard.title}} · '
        span style="font-weight: bold" = '{{selectedCard.readings}} '
        span = '· {{selectedCard.en}} '
        span> style="font-style: italic" = '({{selectedCard.pos}})'
        a :href="selectedCard.href" target="_blank" Show ⮭
        div.hr-title: span Meaning
        div v-html="stripBB(selectedCard.mexp)"
        div.hr-title: span Reading
        div v-html="stripBB(selectedCard.rexp)"

    div.word-comment-form.center-block
      div v-if="forms.comment"
        textarea id="word-comment-textarea" v-model="comment" @keyup.esc="hideCommentForm"
        input type="button" value="Save" @click="saveComment"
      div.editable-text v-else-if="comment" @click="showCommentForm"
        p v-for="commentLine of comment.split('\n')" = '{{commentLine}}'
      div.editable-text v-else="true" style="font-style: italic; color: rgba(128,128,128,0.7)" @click="showCommentForm" Add comment

    div.center-block style="margin-top: 0.8em; margin-bottom: 0.8em"
      span> style="font-weight: bold" Contains:
      div class="connected-word" v-for="(sw, swIndex) of shortWords"
        a> :href="sw.href" {{sw.title}}
        span.action-buttons
          | [
          a @click="deleteConnectedWord('short', swIndex)" 消す
          | ]
      div class="connected-word-none" v-if="!shortWords.length" none
      input<> class="word-connection-autocomplete" type="text" data-word-type="short" placeholder="Add short"

      span> style="font-weight: bold" Belongs to:
      div class="connected-word" v-for="(sw, swIndex) of longWords"
        a> :href="sw.href" {{sw.title}}
        span.action-buttons
          | [
          a @click="deleteConnectedWord('long', swIndex)" 消す
          | ]
      div class="connected-word-none" v-if="!longWords.length" none
      input class="word-connection-autocomplete" type="text" data-word-type="long" placeholder="Add long"

    div.center-block
      div style="opacity: 0.5; font-size: 0.6em; text-align: justify" &#x2139;&#xfe0f; Add only those words, which doesn't form new senses or readings when connected. GOOD examples: 電子＋書籍、図書館＋員. BAD examples: 料理＋人 (reading of 人 can be tricky; we should memorize full word 料理人), 一＋週間 (same here for 一; you may want mark this as 'burned' right away if you wish), 食料＋品 (new sense formed: food + articles = groceries; also, reading of 品 can be ひん or ぴん; you can mark 食料 as 'burned' if you want to reduce count of reviewing words)

    div.hr-title.center-block v-if="sentences.length > 0 || rawSentences.length > 0"
      span style="margin: 1em 0" Sentences

    div.word-sentences.word-sentences-structured.center-block v-if="sentences.length > 0"
      span v-for="(s, sIndex) of sentences"
        | {{bullets[sIndex]}} {{s.jp}}
        span< style="font-size: small" 《{{s.en}}》
        span.action-buttons
          | [
          a.remove-sentence-button @click="removeSentence(sIndex, false)" 消す
          | ] 

    div.word-sentences.center-block v-if="rawSentences.length > 0"
      span v-for="(s, sIndex) of rawSentences"
        | {{bullets[sIndex]}} {{s.jp}}
        span< style="font-size: small" 《{{s.en}}》
        span.action-buttons
          | [
          a.remove-sentence-button @click="removeSentence(sIndex, true)" 消す
          | ] 

javascript:
  var wordApp = new Vue({
    el: '#word-card-app',
    data: #{{word_empty_data.to_json}},
    computed: {
      selectedCard: function() {
        if (this.forms.card !== null) {
          return this.cards[this.forms.card];
        } else {
          return {};
        }
      },
      selectedKrebProgress: function() {
        if (this.forms.kreb !== null) {
          return this.krebs.find(i => i.title === this.forms.kreb).progress;
        } else {
          return {};
        }
      },
      krebClasses: function() {
        var result = {};
        for (kreb of this.krebs) {
          var classes = [];

          if (kreb.is_common) classes.push('word-kreb-common')

          if (kreb.progress) {
            if (kreb.progress.burned_at) {
              classes.push('burned');
            } else if (kreb.progress.learned_at) {
              if (kreb.progress.deck <= 1) classes.push('apprentice');
              else if (kreb.progress.deck == 2) classes.push('guru');
              else if (kreb.progress.deck == 3) classes.push('master');
              else if (kreb.progress.deck >= 6) classes.push('burned');
              else classes.push('enlightened');
            } else if (kreb.progress.flagged === true) {
              classes.push('unlocked');
            }
          }

          result[kreb.title] = classes;
        }

        return result;
      }
    },
    methods: {
      resetWordData() {
        var _wData = #{{word_empty_data.to_json}};
        for (k in _wData) this[k] = _wData[k];
        this.bullets = #{{bullets.to_json}};
      },
      getWordData(seq) {
        this.forms.nowLoading = true;
        $.ajax({
          url: `/api/word/${seq}`,
          method: "GET"
        }).done(data => {
          var _wData = JSON.parse(data);
          this.resetWordData();
          for (k in _wData) {
            this[k] = _wData[k];
          }
          this.forms.nowLoading = false;
        });
      },
      addConnectedWord(wordType, word) {
        if (wordType === 'short') {
          this.shortWords.push(word);
        } else {
          this.longWords.push(word);
        }
      },
      deleteConnectedWord(wordType, wordIndex) {
        var word = wordType === 'short' ? this.shortWords[wordIndex] : this.longWords[wordIndex];
        var postData = {};
        postData[wordType] = word.seq;
        postData[wordType === 'short' ? 'long' : 'short'] = this.seq;

        var ask = confirm(`Are you sure you want to delete ${word.title}?`);
        if (ask) {
          $.ajax({
            url: this.paths.connect,
            method: "DELETE",
            data: postData
          }).done(data => {
            if (wordType === 'short') {
              this.shortWords = this.shortWords.filter(i => i.seq != word.seq);
            } else {
              this.longWords = this.longWords.filter(i => i.seq != word.seq);
            }
          });
        }
      },
      removeSentence(idx, isRawSentence) {
        var ask = confirm("Are you sure?");
        var sentenceUrl = isRawSentence ? this.rawSentences[idx].href : this.sentences[idx].href;
        if (ask) {
          $.ajax({
            url: sentenceUrl,
            method: "DELETE"
          }).done(data => {
            if (isRawSentence) {
              this.rawSentences = this.rawSentences.filter(i => i.href != sentenceUrl);
            } else {
              this.sentences = this.sentences.filter(i => i.href != sentenceUrl);
            }
          });
        };
      },
      learnWord(kreb) {
        $.ajax({
          url: this.paths.learn,
          method: "POST",
          data: {seq: this.seq, kreb: kreb}
        }).done(data => {
          this.krebs.find(i => i.title === kreb).progress = JSON.parse(data);
        });
      },
      burnWord(kreb, progressId) {
        $.ajax({
          url: this.paths.burn,
          method: "POST",
          data: {progress_id: progressId}
        }).done(data => {
          this.krebs.find(i => i.title === kreb).progress = JSON.parse(data);
        });
      },
      flagWord(kreb) {
        $.ajax({
          url: this.paths.flag,
          method: "POST",
          data: {seq: this.seq, kreb: kreb}
        }).done(data => {
          this.krebs.find(i => i.title === kreb).progress = JSON.parse(data);
        });
      },
      saveComment() {
        $.ajax({
          url: this.paths.comment,
          data: {comment: this.comment},
          method: "POST"
        }).done(data => {
          this.forms.comment = false;
        });
      },
      showCommentForm() {
        this.forms.comment = true;
      },
      hideCommentForm() {
        this.forms.comment = false;
      },
      openKrebForm(kreb) {
        if (this.forms.kreb === kreb) {
          this.forms.kreb = null;
        } else {
          this.forms.kreb = kreb;
        }
      },
      openCardForm(cardIndex) {
        if (this.forms.card === cardIndex) {
          this.forms.card = null;
        } else {
          this.forms.card = cardIndex;
        }
      },
      stripBB(str) {
        return str.replace(/\[[a-zA-Z]*?\](.*?)\[\/[a-zA-Z]*?\]/g, "<b>$1</b>")
      }
    }, // end of methods
    mounted() {
      var _wordSeq = #{{word_seq.to_i}};
      if (_wordSeq) this.getWordData(_wordSeq);
    },
    updated() {
      if (this.seq) {
        $('.word-connection-autocomplete').autocomplete({
          source: this.paths.autocomplete,
          minLength: 1,
          select: wordConnectionAutocompleteSelect
        });
      };
    }
  });
  function wordConnectionAutocompleteSelect(event, ui) {
    var wordType = $(this).data('word-type');
    var postData = {};
    postData[wordType] = ui.item.id;
    postData[wordType === 'short' ? 'long' : 'short'] = wordApp.seq;

    $.ajax({
      url: wordApp.paths.connect,
      method: 'POST',
      data: postData
    }).done(data => {
      wordApp.addConnectedWord(wordType, {seq: ui.item.id, title: ui.item.title, href: ui.item.href});
      $(this).val('');
    });

    return false;
  }
