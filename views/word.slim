script src="/js/jquery-ui.min.js"
div.word-card#word-card-app

  - freq_name = {'ichi'=>'i', 'news'=>'N', 'spec'=>'s', 'gai'=>'G', 'nf'=>'F'}
  div.word-krebs
    - [*@word.kele, *@word.rele].each do |ele|
      div.word-kreb class=('word-kreb-common' if kr_common?(ele)) title=(ele['pri'].map{|k,v| "#{k}:#{v}"}.join(', ') if ele['pri']) = ele['keb'] || ele['reb']

  - if @word.card_id.present?
    div style="font-size: 0.8em": a href=path_to(:card).with(@word.card_id) = "WK ##{@word.card_id} (lvl:#{@word.card.level})"

  - bullets = %w(① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿) # white circled numbers

  div
    span style="font-size: x-large" &#x1f1ec;&#x1f1e7;
    - if @word.en.length > 1
      - @word.en.each_with_index do |m2,i|
        = " #{bullets[i]} "
        - if m2['pos'].present?
          span> class="word-gloss-pos" = m2['pos'].map{|i| i[1..-2]}.join(', ')
        = m2['gloss'].join(', ')
    - elsif @word.en.length == 1
      = ' ' + @word.en[0]['gloss'].join(', ')

  - if @word.ru
    div
      span style="font-size: x-large" &#x1f1f7;&#x1f1fa;
      - if @word.ru.length > 1
        - @word.ru.each_with_index do |m2,i|
          = " #{bullets[i]} "
          = m2['gloss'].join(', ')
      - elsif @word.ru.length == 1
        = ' ' + @word.ru[0]['gloss'].join(', ')

  div style="margin: 0.8em 0;"
    span> style="font-weight: bold" Contains:
    div class="connected-word" v-for="(sw, swIndex) of shortWords"
      a> :href="sw.href" {{sw.title}}
      span.action-buttons
        | [
        a @click="deleteConnectedWord('short', swIndex)" 消す
        | ]
    div class="connected-word-none" v-if="!shortWords.length" none
    input<> class="word-connection-autocomplete" type="text" data-word-type="short" placeholder="Add short"

    span> style="font-weight: bold" Belongs to:
    div class="connected-word" v-for="(sw, swIndex) of longWords"
      a> :href="sw.href" {{sw.title}}
      span.action-buttons
        | [
        a @click="deleteConnectedWord('long', swIndex)" 消す
        | ]
    div class="connected-word-none" v-if="!longWords.length" none
    input class="word-connection-autocomplete" type="text" data-word-type="long" placeholder="Add long"

  div style="opacity: 0.5; font-size: 0.6em; text-align: justify" &#x2139;&#xfe0f; Use only those words, which doesn't add new senses or readings when connected. GOOD examples: 電子＋書籍、図書館＋員. BAD examples: 料理＋人 (reading of 人 can be tricky; we should memorize full word 料理人), 一＋週間 (same here for 一; you may want mark this as 'burned' right away if you wish), 食料＋品 (new sense formed: food + articles = groceries; also, reading of 品 can be ひん or ぴん; you can mark 食料 as 'burned' if you want to reduce count of reviewing words)

  h2 Sentences

  div.word-sentences.word-sentences-structured
    span v-for="(s, sIndex) of sentences"
      | {{bullets[sIndex]}} {{s.jp}}
      span< style="font-size: small" 《{{s.en}}》
      span.action-buttons
        | [
        a.remove-sentence-button @click="removeSentence(sIndex, false)" 消す
        | ] 

  div.word-sentences
    span v-for="(s, sIndex) of rawSentences"
      | {{bullets[sIndex]}} {{s.jp}}
      span< style="font-size: small" 《{{s.en}}》
      span.action-buttons
        | [
        a.remove-sentence-button @click="removeSentence(sIndex, true)" 消す
        | ] 

div.word-sentences.word-sentences-structured style="text-align: center;"
  == slim :sentence_form

javascript:
  $(function(){
    $('.word-connection-autocomplete').autocomplete({
      source: "#{{path_to(:autocomplete_word)}}",
      minLength: 1,
      select: function(event,ui) {
        var wordType = $(this).data('word-type');
        var postData = {};
        postData[wordType] = ui.item.id;
        postData[wordType === 'short' ? 'long' : 'short'] = #{{@word.seq}};

        $.ajax({
          url: "#{{path_to(:word_connect)}}",
          method: 'POST',
          data: postData
        }).done(data => {
          app.addConnectedWord(wordType, {seq: ui.item.id, title: ui.item.title, href: ui.item.href});
          $(this).val('');
        });

        return false;
      }
    });
  });

  var wordApp = new Vue({
    el: '#word-card-app',
    data: {
      bullets: #{{bullets.to_json}},
      shortWords: #{{@word.short_words.map{|i| {seq: i.seq, title: i.krebs[0], href: path_to(:word).with(i.seq)}}.to_json }},
      longWords: #{{@word.long_words.map{|i| {seq: i.seq, title: i.krebs[0], href: path_to(:word).with(i.seq)}}.to_json }},
      rawSentences: #{{@sentences.map{|i| {jp: i.japanese, en: i.english, href: path_to(:sentence).with(i.id)}}.to_json}},
      sentences: #{{@word.all_sentences.map{|i| {jp: i.japanese, en: i.english, href: path_to(:sentence).with(i.id)}}.to_json}}
    },
    methods: {
      addConnectedWord(wordType, word) {
        if (wordType === 'short') {
          this.shortWords.push(word);
        } else {
          this.longWords.push(word);
        }
      },
      deleteConnectedWord(wordType, wordIndex) {
        var word = wordType === 'short' ? this.shortWords[wordIndex] : this.longWords[wordIndex];
        var postData = {};
        postData[wordType] = word.seq;
        postData[wordType === 'short' ? 'long' : 'short'] = #{{@word.seq}};

        var ask = confirm(`Are you sure you want to delete ${word.title}?`);
        if (ask) {
          $.ajax({
            url: "#{{path_to(:word_connect)}}",
            method: "DELETE",
            data: postData
          }).done(data => {
            if (wordType === 'short') {
              this.shortWords = this.shortWords.filter(i => i.seq != word.seq);
            } else {
              this.longWords = this.longWords.filter(i => i.seq != word.seq);
            }
          });
        }
      },
      removeSentence(idx, isRawSentence) {
        var ask = confirm("Are you sure?");
        var sentenceUrl = isRawSentence ? this.rawSentences[idx].href : this.sentences[idx].href;
        if (ask) {
          $.ajax({
            url: sentenceUrl,
            method: "DELETE"
          }).done(data => {
            if (isRawSentence) {
              this.rawSentences = this.rawSentences.filter(i => i.href != sentenceUrl);
            } else {
              this.sentences = this.sentences.filter(i => i.href != sentenceUrl);
            }
          });
        };
      }
    }
  });
