ruby:
  groups = {
        just_unlocked: {title: 'Unlocked', color: :green},
        just_learned: {title: 'New', color: :blue},
        failed: {title: 'Failed', color: :red},
        expired: {title: 'Expired', color: :yellow}}
  tt = {r: :radicals, k: :kanjis, w: :words}

table.study-links-table
  tr
    td
    td Radicals
    td Kanji
    td Words
  tr
    td Cards left
    - %w(r k w).each do |k|
      td
        - unlocked = @current_counters[[k, true]] || 0
        - total = unlocked + (@current_counters[[k, false]] || 0)
        = "#{unlocked}/#{total}"
  - groups.each do |gk,gv|
    tr
      td = gv[:title]
      - %w(r k w).each do |k|
        - i = @counters[gk][k] || 0
        td
          - if i > 0
            - study_path = (gk == :just_unlocked ? path_to(:random_unlocked).with(tt[k.to_sym]) : path_to(:study).with(tt[k.to_sym], gk) )
            a class="study-button #{gv[:color]}" href=study_path = i
          - else
            ' -

ruby:
  days_in_graph = 21

  _r_sched = (@counters[:just_learned]['r']||0) + (@counters[:expired]['r']||0) + (@counters[:failed]['r']||0)
  _k_sched = (@counters[:just_learned]['k']||0) + (@counters[:expired]['k']||0) + (@counters[:failed]['k']||0)
  _w_sched = (@counters[:just_learned]['w']||0) + (@counters[:expired]['w']||0) + (@counters[:failed]['w']||0)
  _sched = {'r' => _r_sched, 'k' => _k_sched, 'w' => _w_sched}
  day_cards = {Date.today => Statistic.new(date: Date.today, scheduled: _sched)}

  ss = Statistic.where(date: (Date.today + 1)..(Date.today + days_in_graph - 1))
  ss.each {|s| day_cards[s.date] = s }

  _height = 70
  _width = 22
  _gap = 2

  maxval = 1 # cannot be less than 1
  graph_width = _width * days_in_graph
  half_bar_width = _width/2.0 - _gap/2.0
  day_cards.each do |k,v|
    maxval = v.scheduled_total if v.scheduled_total > maxval
  end

div.hr-title style="margin: 1em 0 1.2em 0": span Graphs
' Scheduled (for upcoming 3 weeks):
br
svg.upcoming-week-graph viewBox="0 0 #{graph_width} #{_height+30}"
  - d = Date.today
  - iter = 0
  - while d <= (Date.today + days_in_graph - 1)
    - v = day_cards[d] || Statistic.new
    - bar_height = _height*v.scheduled_total/maxval.to_f
    g transform=("translate(#{iter*_width},10)")
      - height_shift = 0
      - %w(w k r).each do |s|
        - part_height = _height*v.scheduled[s]/maxval.to_f
        rect class="bar #{s}" x=0 y=_height-bar_height+height_shift width=half_bar_width*2 height=part_height
        - height_shift += part_height
      text x=half_bar_width y=_height+12 = d.strftime("%a")
      text x=half_bar_width y=_height-bar_height-2 = v.scheduled_total
    - iter += 1
    - d += 1

ruby:
  day_cards = {}

  ss = Statistic.where(date: (Date.today - days_in_graph + 1)..(Date.today))
  ss.each {|s| day_cards[s.date] = s }

  maxval = 1 # cannot be less than 1
  day_cards.each do |k,v|
    maxval = v.learned_total if v.learned_total > maxval
  end

br
' Learning history (past 3 weeks):
br
svg.upcoming-week-graph viewBox="0 0 #{graph_width} #{_height+30}"
  - d = Date.today - days_in_graph + 1
  - iter = 0
  - while d <= Date.today
    - v = day_cards[d] || Statistic.new
    - bar_height = _height*v.learned_total/maxval.to_f
    g transform=("translate(#{iter*_width},10)")
      - height_shift = 0
      - %w(w k r).each do |s|
        - part_height = _height*v.learned[s]/maxval.to_f
        rect class="bar #{s}" x=0 y=_height-bar_height+height_shift width=half_bar_width*2 height=part_height
        - height_shift += part_height
      text x=half_bar_width y=_height+12 = d.strftime("%a")
      text x=half_bar_width y=_height-bar_height-2 = v.learned_total
    - iter += 1
    - d += 1

ruby:
  level_dates = []
  #not_yet_learned = Card.where(scheduled: nil).group(:level).count
  not_yet_learned = Card.where(learned: false).group(:level).count
  level_dates << Action.where(action_type: 2).order(created_at: :asc).first.created_at.to_datetime
  (1..60).each do |i|
    break if not_yet_learned[i]
    # latest learn action at current level
    a = Action.eager_load(:card).where(action_type: 2, cards: {level: i}).order(created_at: :desc).first
    level_dates << a.created_at.to_datetime
  end
  level_dates << DateTime.now
  level_duration = {}
  (level_dates.count - 1).times do |i|
    level_duration[i+1] = (level_dates[i+1] - level_dates[i]).to_f.round(1)
  end

br
' Levels duration:
= level_duration.inspect

