script src="/js/Chart.min.js"
ruby:
  groups = {
        just_learned: {title: 'New', color: :blue},
        failed: {title: 'Failed', color: :red},
        expired: {title: 'Expired', color: :yellow}}
  tt = {r: :radicals, k: :kanjis, w: :words}
  clevel = current_user.present? ? current_user.current_level : 1
  uc_arel = UserCard.arel_table
  clevel_cards = Card.where(level: clevel).with_uinfo(current_user)
  cstat = {}
  %w(r k w total).each {|k|cstat[k] = {unlocked: 0, locked: 0, learned: 0, total: 0}}
  clevel_cards.each do |cc|
    _t = if cc.uinfo.blank? || (cc.uinfo.unlocked == false && cc.uinfo.learned == false)
        :locked
    elsif cc.uinfo.unlocked == true && cc.uinfo.learned == false
        :unlocked
    elsif cc.uinfo.unlocked == true && cc.uinfo.learned == true
        :learned
    end
    cstat[cc.element_type][_t]        += 1
    cstat[cc.element_type][:total]    += 1
    cstat['total'][_t]     += 1
    cstat['total'][:total] += 1
  end

div.stat-table-block style="margin-top: 1em;"
  div.hr-title: span = "#{DEGREES[(clevel-1)/10]}: Level #{clevel}"
  table
    tr
      td
      td title="Locked" ðŸ”’
      td title="Unlocked" ðŸ”°
      td title="Learned" ðŸŽ“
      td Learned %
    - %w(r k w total).each do |k|
      tr
        td class=k = k == 'total' ? k : INFODIC[k.to_sym][:japanese]
        td = cstat[k][:locked]
        td
          - unless k == 'total'
            a.study-button.green = cstat[k][:unlocked]
          - else
            = cstat[k][:unlocked]
        td = cstat[k][:learned]
        td = "#{(cstat[k][:learned].to_f / cstat[k][:total] * 100).round(1)}%"

div.stat-table-block
  div.hr-title: span SRS
  table
    tr
      td
      td New
      td Failed
      td Expired
      td title="Total Learned" ðŸŽ“
    - %w(r k w).each do |k|
      tr
        td class=k = k == 'total' ? k : INFODIC[k.to_sym][:japanese]
        - groups.each do |gk,gv|
          - i = @counters[gk][k] || 0
          td
            - if i > 0
              a class="study-button #{gv[:color]}" href=path_to(:study).with(tt[k.to_sym], gk) = i
            - else
              ' -
        td = @counters[:any_learned][k]

div.hr-title style="margin: 1em 0 1.2em 0": span Graphs
' Scheduled (for upcoming 3 weeks):
br
div.graph
  canvas id='scheduled-chart'

ruby:
  days_in_graph = 21
  # scd = Scheduled chart data
  scd = {labels: [], datasets: [
        {label: 'Radicals', backgroundColor: '#0af', data: []},
        {label: 'Kanji', backgroundColor: '#f0a', data: []},
        {label: 'Words', backgroundColor: '#a0f', data:[]}
    ]}

  scd[:datasets][0][:data] << (@counters[:just_learned]['r']||0) + (@counters[:expired]['r']||0) + (@counters[:failed]['r']||0)
  scd[:datasets][1][:data] << (@counters[:just_learned]['k']||0) + (@counters[:expired]['k']||0) + (@counters[:failed]['k']||0)
  scd[:datasets][2][:data] << (@counters[:just_learned]['w']||0) + (@counters[:expired]['w']||0) + (@counters[:failed]['w']||0)
  scd[:labels] << Date.today.strftime("%d")

  ss = Statistic.where(user: current_user, date: (Date.today + 1)..(Date.today + days_in_graph - 1))
  sh = {}
  ss.each {|i| sh[i.date] = [i.scheduled['r'], i.scheduled['k'], i.scheduled['w']]}

  d = Date.today + 1
  while d < Date.today + days_in_graph
    scd[:datasets][0][:data] << (sh[d].present? ? sh[d][0] : 0)
    scd[:datasets][1][:data] << (sh[d].present? ? sh[d][1] : 0)
    scd[:datasets][2][:data] << (sh[d].present? ? sh[d][2] : 0)
    scd[:labels] << d.strftime("%d")
    d += 1
  end

javascript:
  var scheduledChart = new Chart($('#scheduled-chart'), {
    type: 'bar',
    data: #{{scd.to_json}},
    options: {
        tooltips: {enabled: false, mode: 'index', intersect: false},
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            xAxes: [{
                stacked: true,
                gridLines: {display: false, drawBorder: false},
                ticks: {fontSize: 9, fontFamily: 'sans-serif'}
            }], yAxes: [{
                stacked: true,
                gridLines: {display: false, drawBorder: false},
                ticks: {display: false}
            }]
        },
    }

  });
  

/ruby:
/  gdata = [[_w_sched, _k_sched, _r_sched]]
/  gdesc = [Date.today.strftime("%d")]
/
/  ss = Statistic.where(date: (Date.today + 1)..(Date.today + days_in_graph - 1))
/  sh = {}
/  ss.each {|i| sh[i.date] = [i.scheduled['w'], i.scheduled['k'], i.scheduled['r']]}
/
/  d = Date.today + 1
/  while d < Date.today + days_in_graph
/    gdata << (sh[d] || [0,0,0])
/    gdesc << d.strftime("%d")
/    d += 1
/  end
/
/div.hr-title style="margin: 1em 0 1.2em 0": span Graphs
/' Scheduled (for upcoming 3 weeks):
/br
/== slim :svg_graph, locals: {gdata: gdata, gdesc: gdesc, classes: [:w, :k, :r]}
/
/ruby:
/  day_cards = {}
/
/  ss = Statistic.where(date: (Date.today - days_in_graph + 1)..(Date.today))
/  sh = {}
/  ss.each {|i| sh[i.date] = [i.learned['w'], i.learned['k'], i.learned['r']]}
/
/  gdata = []
/  gdesc = []
/  d = Date.today - days_in_graph + 1
/  while d <= Date.today
/    gdata << (sh[d] || [0,0,0])
/    gdesc << d.strftime("%d")
/    d += 1
/  end
/
/br
/' Learning history (past 3 weeks):
/br
/== slim :svg_graph, locals: {gdata: gdata, gdesc: gdesc, classes: [:w, :k, :r]}
/
/ruby:
/  level_dates = []
/  #not_yet_learned = Card.where(scheduled: nil).group(:level).count
/  not_yet_learned = Card.where(learned: false).group(:level).count
/  first_action = Action.where(action_type: 2).order(created_at: :asc).first
/  if first_action.present?
/    level_dates << first_action.created_at.to_datetime
/    (1..60).each do |i|
/      break if not_yet_learned[i]
/      # latest learn action at current level
/      a = Action.eager_load(:card).where(action_type: 2, cards: {level: i}).order(created_at: :desc).first
/      level_dates << a.created_at.to_datetime
/    end
/  end
/  level_dates << DateTime.now
/  level_duration = {}
/  (level_dates.count - 1).times do |i|
/    level_duration[i+1] = (level_dates[i+1] - level_dates[i]).to_f.round(1)
/  end

/br
/' Levels duration
/br
/== slim :svg_graph, locals: {gdata: level_duration.values.map{|i|[i]}, gdesc: level_duration.keys, classes: [:r]}
/
/ruby:
/  t = Card.arel_table
/  decks_all = Card.any_learned.group(:deck).count
/  decks_scheduled = Card.any_learned.where(t[:scheduled].lteq(Date.today).
/                  or(t[:scheduled].eq(nil))).group(:deck).count
/  max_deck = Card.where(Card.arel_table[:deck].lt(100)).order(deck: :desc).pluck(:deck).first
/  max_deck = 7 if max_deck < 7
/  gdata = []
/  gdesc = []
/  (0..max_deck).each do |d|
/    _a = (decks_all[d] || 0)
/    _s = (decks_scheduled[d] || 0)
/    gdata << [_a - _s, _s]
/    gdesc << _s
/  end
/
/br
/' Decks:
/br
/== slim :svg_graph, locals: {gdata: gdata, gdesc: gdesc, classes: [:r, :k]}

